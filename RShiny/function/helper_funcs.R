# helper_funcs.R

tabTitle =
  ## Creates an appropriately styled title
  function(x)
    h3(class = "tabTitle", x)
tabDesc =
  ## Creates an appropriately styled description
  ## If NA, returns NULL
  function(x)
    if(!is.na(x)) tags$p(class = "tabDesc", x) else NULL
tabPwT =
  ## tabPanel with Title (using tabTitle)
  ## Also searches for a match in `tabdesc`
  ##  (a named vector of descriptions found in "ui_doctabs.R")
  ## If one is found, adds the description below the title
  function(title, ...){
    tabPanel(title,
             div(class = "tabTitlePanel",
                 tabTitle(title),
                 tabDesc(tabdesc[title][[1]]),
                 div(class = "tabTitlePanel-end")
             ),
             ...
    )
  }


dashboardPage =
  ## Modified navbarPage from shiny
  ## Cuts bloat and enables use of tags$head with `thead`
  function(title, ..., id = "dashboard", thead = NULL, header = NULL, footer = NULL, windowTitle = title){
    pageTitle = title
    navbarClass = "navbar navbar-default"
    tabs = list(...)
    tabset = shiny:::buildTabset(tabs, "nav navbar-nav", NULL, id)
    containerDiv = div(class = "container", div(class = "navbar-header", 
                                                span(class = "navbar-brand", pageTitle)), tabset$navList)
    contentDiv = div(class = "container-fluid")
    if(!is.null(header))
      contentDiv = tagAppendChild(contentDiv, div(class = "row", header))
    contentDiv = tagAppendChild(contentDiv, tabset$content)
    if(!is.null(footer)) 
      contentDiv = tagAppendChild(contentDiv, div(class = "row", footer))
    bootstrapPage(title = windowTitle, thead,
                  tags$nav(class = navbarClass, role = "navigation", containerDiv),
                  contentDiv)
  }


selectInputF =
  ## A wrapper for selectInput with selectize = FALSE
  function(inputId, label, choices, selected = NULL)
    shiny:::selectInput(inputId, label, choices, selected, selectize = FALSE)

checkboxComboInput =
  ## A combo input that presents a Checkbox Group Input
  ##  with a "Select all" checkbox
  ## This functions goes in ui.R while
  ##  `checkboxComboServer` should go in server.R
  ##
  ## Arguments:
  ##  Simplified versions of the arguments to `checkboxGroupInput`
  ##  Only difference is that `selected` is now a logical
  ##   If TRUE, all choices selected
  ##   If FALSE (default), first choice is selected
  ##
## Example:
## = ui.R =
## checkboxComboInput("compList", "Choose Products:", all_levels$Product)
## = server.R =
## checkboxComboServer("compList", all_levels$Product, input, session)
function(inputId, label, choices, selected = FALSE){
  label = shiny:::controlLabel(inputId, label)
  
  chkboxAll = div(class = "checkbox checkboxcombo-all", tags$label(
    tags$input(id = paste0(inputId, "AllChk"), type = "checkbox"),
    tags$span("Select all")
  ))
  if(selected) chkboxAll$children[[1]]$children[[1]]$attribs$checked = "checked"
  
  choices = shiny:::choicesWithNames(choices)
  selected = if(selected == TRUE) choices else choices[1]
  chkboxGroup = shiny:::generateOptions(inputId, choices, selected, FALSE)
  
  tags$div(id = inputId,
           class = "form-group shiny-input-checkboxgroup shiny-input-container checkboxcombo",
           label, chkboxAll, chkboxGroup
  )
}
checkboxComboServer =
  ## The function to place in server.R to provide the "Select all"
  ##  functionality to `checkboxComboInput`
  ##
  ## Arguments:
  ##  "input" and "session" come straight from the arguments to `shinyServer`
  ##    i.e. shinyServer(function(input, output, session){...})
  ##  "inputId" and "choices" should match those given to `checkboxComboInput`
  ##  "cdef" is the index of the choice to be selected when
  ##    select all is unticked.
  function(input, session, inputId, choices, cdef = 1) observe({
    if(input[[paste0(inputId, "AllChk")]] == TRUE)
      updateCheckboxGroupInput(session, inputId, selected = choices)
    else
      updateCheckboxGroupInput(session, inputId, selected = choices[cdef])
  })
condComboServer =
  ## Add a checkboxComboServer for each checkboxComboInput
  ##  generated by condInputs, in a single call.
  ## "cats" and "choices" come from the arguments to `condInputs`
  ## The for loop requires a `local` due to funny shiny business.
  function(input, session, inputId, cats, choices, cdef = 1) observe({
    for(i in 1:length(cats)) local({
      curcat = cats[i]
      curID = condID(inputId, curcat)
      curchoices = choices[[curcat]]
      checkboxComboServer(input, session, curID, curchoices, cdef)
    })
  })

condInputs =
  ## A wrapper to provide a systematic way to create conditional inputs
  ## This functions goes in ui.R while
  ##  `condInputServer` should go in server.R
  ##
  ## Arguments:
  ## -inputId-
  ## The base ID to be given to the inputs, as a character vector of length 1
  ##
  ## -cats-
  ## The input categories, of which one is shown at a given point
  ##  in time based on whether the conditions are met.
## Given as a character vector, possibly named.
## If named, these names are passed to the "label" argument
##  e.g. c("Domestic" = "dom", "International" = "int")
##
## -choices-
## A named list of choices corresponding to the categories provided in "cats"
##  e.g. list(dom = c("Auckland", "Wellington"),
##            int = c("UK", "US"))
##
## -type-
## The type of input, either a function or the name
##  of a function (as a character vector of length 1)
##  e.g.  "selectInputF"
##  e.g.2 "checkboxComboInput"
##
## -label-
## The labels passed to the inputs.
## By default this is generated automatically from
##  "names(cats)" if it exists, or "cats" itself.
## But custom labels could be provided here as a
##  character vector corresponding to "cats".
##
## -cond_simple- and -cond_full-
## Used to provide the conditions. Only one of these should be provided.
## See `condParse` for exact specifications.
function(inputId, cats, choices, type, labels = NULL,
         cond_simple = NULL, cond_full = NULL, ...){
  if(is.null(labels)){
    if(!is.null(names(cats)))
      labels = names(cats)
    else
      labels = cats
  }
  labelfull = paste0("Choose ", labels, ":")
  
  ## Generate conditional panels
  condition = condParse(cats, cond_simple, cond_full, "js")
  compPanels = list()
  for(i in 1:length(cats)){
    curcat = cats[i]
    curlab = labelfull[i]
    curargs = list(
      inputId = condID(inputId, curcat),
      label = curlab,
      choices = choices[[curcat]]
    )
    curargs = c(curargs, list(...))
    compPanels[[curcat]] = conditionalPanel(condition[i], do.call(type, curargs))
  }
  
  do.call(tagList, compPanels)
}

condInputServer =
  ## The function to place in server.R to easily grab the input value
  ##  provided by an active conditional input generated using `condInputs`
  ##
  ## Arguments:
  ##  "input" comes straight from the arguments to `shinyServer`
  ##    i.e. shinyServer(function(input, output, session){...})
  ##  "inputId", "cats" and "cond_simple"/"cond_full"
  ##    should match those given to `condInputs`
  function(input, inputId, cats, cond_simple = NULL, cond_full = NULL){
    ## Check conditions
    condition = condParse(cats, cond_simple, cond_full, "R")
    condchk = sapply(condition, function(x) eval(parse(text = x)))
    
    input[[condID(inputId, cats[condchk])]]
  }

condParse =
  ## A parser used by `condInputs` and `condInputServer`
  ##  to handle "cond_simple" and "cond_full" arguments
  ## Only one of "cond_simple" or "cond_full" should be provided.
  ## If both are provided, only "cond_simple" is used.
  ##
  ## -cond_simple-
  ## Used for simple conditions with a direct, one-to-one
  ##  correspondence from an input to the conditions.
  ## This is the inputId of an input (usually a `radioButtons`)
  ##  that will choose one of the conditional inputs.
  ## e.g. cond_simple = "compclass"
##  is interpreted to mean:
##   if(input$compclass == cats[1])
##   then <show input corresponding to cats[1]>
##
## -cond_full-
## Used for more complicated conditions.
## A named list corresponding to the categories provided in "cats"
##  each containing a named list where:
##  - the names correspond to the inputId of an input
##  - the contents correspond to the values of that input
##    for which the condition is satisfied.
## e.g. the following is roughly equivalent to cond_simple = "compclass"
##  cond_full = list(cats[1] = list(compclass = cats[1]))
## e.g.2 a case where the condition for "RTO" is met for
##   both "mi" and "mo" for input$compclass
##  and where the condition for "OriginDom" is met when
##   both input$compclass == "oo" and input$domint == "Domestic"
##  cond_full = list(RTO = list(compclass = c("mi", "mo")),
##                   OriginDom = list(compclass = "oo", domint = "Domestic"))
function(cats, cond_simple = NULL, cond_full = NULL, type = "js"){
  ## Set key values to switch between JavaScript and R condition parsing
  subskey = if(type == "js") "." else "$"
  
  if(!is.null(cond_simple)){
    ## Simple conditions
    condition = paste0("input", subskey, cond_simple, "==", sapply(cats, deparse))
  } else{
    ## Complex conditions
    condition = NULL
    for(i in 1:length(cats)){
      curcat = cats[i]
      catconds = cond_full[[curcat]]
      subconds = NULL
      for(j in 1:length(catconds)){
        subconds[j] = paste0("input", subskey, names(catconds)[j], "==",
                             sapply(catconds[[j]], deparse), collapse = "||")
      }
      condition[i] = paste0("(", subconds, ")", collapse = "&&")
    }
  }
  condition
}

condID =
  ## Simple wrapper for removing spaces from cats for ID generation
  function(baseID, curcat)
    paste0(baseID, gsub(" ", "_", curcat))

tableCombo =
  ## Combination input of a table and download button for table
  function(inputId) tagList(
    downloadButton(paste0(inputId, "Down"), "Download table of values"),
    tags$div(tags$form(class = "well",
                       dataTableOutput(inputId)
    ))
  )
tableComboDown =
  ## Handle download of Data Table
  function(curtab, filename){
    ## Tidy filename, not strictly necessary on Windows sytems
    filename = gsub(" ", "_", filename, fixed = TRUE)
    filename = gsub(",", "", filename, fixed = TRUE)
    downloadHandler(
      filename = paste0(filename, "_DownloadDate_", Sys.Date(), ".csv"),
      content = function(file) write.csv(curtab, file, row.names = FALSE),
      contentType = "text/csv"
    )
  }